import os
import io
import subprocess
import abc
import codes

CARGO_TOML_TEMPLATE = """[package]
name = "{project_name}"
version = "0.1.0"
edition = "2021"
description = "Autogenerated Bellman circuit!"

[dependencies]
bellman = "0.13.1"
ff = "0.12"
bls12_381 = "0.7"
rand = "0.8.5"
"""

MAIN_RS_TEMPLATE = """
mod number;
#[allow(unused_imports)]
use number::Number;

use bellman::groth16::{
    create_random_proof, generate_random_parameters, prepare_verifying_key, verify_proof,
};
use bellman::{Circuit, ConstraintSystem, SynthesisError};
use bls12_381::Bls12;
use ff::{PrimeField, PrimeFieldBits};
use rand::thread_rng;
use std::marker::PhantomData;

#[derive(Debug, Default, Clone)]
pub struct GeneratedCircuit<S: PrimeField + PrimeFieldBits> {
    pub gen_params: bool,
    pub _phantom: PhantomData<S>,
}

impl<S: PrimeField + PrimeFieldBits> Circuit<S> for GeneratedCircuit<S> {
    fn synthesize<CS: ConstraintSystem<S>>(self, cs: &mut CS) -> Result<(), SynthesisError> {
        {generated_code}
        Ok(())
    }
}

fn main() {
    let mut rng = thread_rng();
    let params = {
        let c = GeneratedCircuit {
            gen_params: true,
            _phantom: PhantomData,
        };

        generate_random_parameters::<Bls12, _, _>(c, &mut rng).unwrap()
    };
    let pvk = prepare_verifying_key(&params.vk);
    let c = GeneratedCircuit {
        gen_params: false,
        _phantom: PhantomData,
    };
    let proof = create_random_proof(c, &params, &mut rng).unwrap();
    assert!(verify_proof(&pvk, &proof, &[]).is_ok());
}
"""

VAR_DECL_TEMPLATE = """let {} v{} = Number::alloc(&mut *cs,
    {}
)?;"""

CONSTRAIN_TEMPLATE = """cs.enforce(
    || "",
    |lc| lc {a},
    |lc| lc {b},
    |lc| lc {c},
);"""


class Hint(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def generate_rust(self):
        pass


class Constant(Hint):
    def __init__(self, constant: int):
        self.constant = constant

    def generate_rust(self):
        return "Some(S::from({}))".format(self.constant)


def expand_number(num):
    expanded = "+".join(
        [
            "(S::from({}), &v{})".format(coeff, ind)
            if coeff != 1
            else "&v{}".format(ind)
            for (ind, coeff) in num.vars.items()
        ]
    )
    if expanded.startswith("(S::from"):
        expanded = "(&Number::zero() + " + expanded + ")"
    return "(" + expanded + ")"


class Multiply(Hint):
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def generate_rust(self):
        return "{}.get_value().zip({}.get_value()).map(|(a,b)|a*b)".format(
            expand_number(self.a), expand_number(self.b)
        )


class ToBits(Hint):
    def __init__(self, num, bits):
        self.num = num
        self.bits = bits

    def generate_rust(self):
        return "{}.get_value().map(|n|n.to_le_bits().iter().map(|b| Some(if *b{{S::one()}} else {{S::zero()}})).collect::<Vec<_>>()).unwrap_or(vec![None; {}])".format(
            expand_number(self.num), self.bits
        )


class Loop:
    def __init__(self, ctx, cnt):
        self.ctx = ctx
        self.cnt = cnt

    def __enter__(self):
        self.ctx.output += "for _ in 0..{} {{\n".format(self.cnt)
        return self

    def __exit__(self, type, value, traceback):
        self.ctx.output += "\n}"


class Context:
    def __init__(self):
        self.vars = []
        self.output = ""

    def loop(self, cnt):
        return Loop(self, cnt)

    def print_num(self, num):
        self.output += 'if !self.gen_params {{ println!("{{:?}}", {}.get_value().unwrap()); }}\n'.format(
            expand_number(num)
        )

    def print(self, s):
        self.output += 'if !self.gen_params {{ println!("{}"); }}\n'.format(s)

    def set(self, dst, src):
        self.output += "v{} = {}.clone();".format(dst, expand_number(src))

    def alloc(self, hint, mutable=False):
        v = Variable(self, len(self.vars), hint)
        self.vars.append(v)
        self.output += (
            VAR_DECL_TEMPLATE.format(
                "mut" if mutable else "", v.index, v.hint.generate_rust()
            )
            + "\n"
        )
        return Number(self, {v.index: 1})

    def alloc_many(self, hint):
        self.output += (
            "let vars = {}.into_iter().map(|v|Number::alloc(&mut *cs, v)).collect::<Result<Vec<Number<S>>, SynthesisError>>();".format(
                hint.generate_rust()
            )
            + "\n"
        )
        # return Number(self, {v.index: 1})

    # A * B == C
    def constrain(self, a, b, c):
        def number_lc_add(n: Number):
            return " ".join(
                [
                    "+ (S::from({}),v{}.get_lc())".format(coeff, ind)
                    if coeff != 1
                    else "+ v{}.get_lc()".format(ind)
                    for ind, coeff in n.vars.items()
                ]
            )

        self.output += (
            CONSTRAIN_TEMPLATE.format(
                a=number_lc_add(a), b=number_lc_add(b), c=number_lc_add(c)
            )
            + "\n"
        )

    def add_number(self, num):
        self.numbers.append(num.vars.copy())

    def mul(self, a, b):
        ret = self.alloc(hint=Multiply(a, b))
        self.constrain(a, b, ret)
        return ret

    def compile(self, path, project_name):
        libs = {"number": codes.NUMBER_RS}

        proj = os.path.join(path, project_name)
        cargo_toml = os.path.join(proj, "Cargo.toml")
        with io.open(cargo_toml, "w") as f:
            f.write(CARGO_TOML_TEMPLATE.format(project_name=project_name))
        src = os.path.join(proj, "src")
        os.makedirs(src, exist_ok=True)

        for (file_name, content) in libs.items():
            with io.open(os.path.join(src, file_name + ".rs"), "w") as f:
                f.write("#![allow(dead_code)]\n" + content)

        main_rs = os.path.join(src, "main.rs")

        with io.open(main_rs, "w") as f:
            f.write(MAIN_RS_TEMPLATE.replace("{generated_code}", self.output))
        subprocess.run(["cargo", "fmt", "--manifest-path", cargo_toml])
        subprocess.run(["cargo", "run", "--manifest-path", cargo_toml])


class Variable:
    def __init__(self, ctx, index, hint):
        self.ctx = ctx
        self.index = index
        self.hint = hint

    def __str__(self):
        return "Variable({})".format(self.index)


class Number:
    def __init__(self, ctx, vars):
        self.ctx = ctx
        self.vars = vars

    def as_variable(self):
        if len(self.vars) != 1 or list(self.vars.items())[0][1] != 1:
            raise Exception()
        return list(self.vars.items())[0][0]

    def set(self, other):
        self.ctx.set(self.as_variable(), other)

    def __mul__(self, other):
        if type(other) == int:
            return Number(self.ctx, {ind: v * other for (ind, v) in self.vars.items()})
        elif type(other) == Number:
            return self.ctx.mul(self, other)
        else:
            raise Exception()

    def __add__(self, other):
        new_vars = self.vars.copy()
        if type(other) == Number:
            for v, coeff in other.vars.items():
                if v not in new_vars:
                    new_vars[v] = 0
                new_vars[v] += coeff
        else:
            raise Exception()
        return Number(ctx, new_vars)

    def __str__(self):
        return "Number({})".format(self.vars)


ctx = Context()


a = ctx.alloc(Constant(3), mutable=True)
print(a)
aaa = ctx.alloc_many(ToBits(a, 16))
ctx.compile(".", "circuit")
